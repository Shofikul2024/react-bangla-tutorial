# Responding To Events

React আপনাকে আপনার JSX-এ ইভেন্ট হ্যান্ডলার যোগ করতে দেয়। ইভেন্ট হ্যান্ডলার হল আমাদের নিজস্ব তৈরি করা ফাংশন যা ইউজারের ক্লিক করা, হোভার করা, ফর্ম ইনপুটগুলিতে ফোকাস করা ইত্যাদি ইন্টারঅ্যাকশনের প্রতিক্রিয়া হিসাবে ট্রিগার হবে।

**এই পাঠে যা শিখব:**

- ইভেন্ট হ্যান্ডলার যোগ করার বিভিন্ন উপায়
- প্যারেন্ট কম্পোনেন্ট থেকে চাইল্ড কম্পোনেন্টে ইভেন্ট হ্যান্ডলিং লজিক পাঠানোর প্রক্রিয়া
- ইভেন্ট কিভাবে প্রোপাগেট হওয়া শুরু হয় এবং তা কীভাবে ইভেন্ট হ্যান্ডেলিং থামানো যায়

## কিভাবে কম্পোনেন্টে Event Handlers যোগ করব?

কম্পোনেন্ট এ ইভেন্ট হ্যান্ডেলার যোগ করার জন্য প্রথমে আমাদের একটি ফাংশন তৈরি করতে হবে। এবং কম্পোনেন্টে এই ফাংশনটি `props` আকারে পাঠাতে হবে।

**ইউজার বাটনে ক্লিক করলে আপনি এই তিনটি ধাপ অনুসরণ করে তাকে একটি মেসেজ দেখাতে পারেন-**

1. একটি handleClick নামে একটি ফাংশন ঘোষণা করুন।
2. আপনার তৈরি করা ফাংশনের ভিতরে মেসেজ দেখানোর লজিক ডেভেলপ করুন।
3. `<button>` JSX এ `onClick={handleClick}` যোগ করুন।

```jsx
export default function Button() {
  function handleClick() {
    alert("You clicked me!");
  }

  return <button onClick={handleClick}>Click me</button>;
}
```

আমরা _handleClick_ ফাংশনটি ডিফাইন করেছি এবং এটি `props` হিসেবে **_button_** এ পাশ করেছি। এখানে _handleClick_ একটি _ইভেন্ট হ্যান্ডেলার_। **Event Handler** ফাংশনগুলোঃ

1. সাধারণত Component এর ভিতরে event handler যোগ করা হয়।
2. নামের শুরুতে handle এবং তারপর ইভেন্টের নাম থাকে।
3. প্রচলিত রীতি অনুযায়ী, ইভেন্ট হ্যান্ডলারগুলোর নাম handle দিয়ে শুরু হয় এবং তারপর ইভেন্টের নাম যোগ করা হয়। আমরা প্রায়ই `onClick={handleClick}`, `onMouseEnter={handleMouseEnter}` ইত্যাদি দেখতে পাবো।

**বিকল্পভাবে, JSX এর মধ্যেই একটি ইনলাইন ইভেন্ট হ্যান্ডেলার ডিফাইন করতে পারি:**

```jsx
<button
  onClick={function handleClick() {
    alert("আপনি আমাকে ক্লিক করেছেন!");
  }}
></button>
```

**অথবা, আরও সংক্ষিপ্তভাবে, একটি এ্যারো ফাংশন ব্যবহার করে:**

```jsx
<button
  onClick={() => {
    alert("আপনি আমাকে ক্লিক করেছেন!");
  }}
></button>
```

<span style={{ color: "red" }}>
  _ছোট ফাংশনের জন্য ইনলাইন ইভেন্ট হ্যান্ডলার সুবিধাজনক।_
</span>

### ইভেন্ট হ্যান্ডলারে ফাংশন পাস করার সঠিক ও ভুল পদ্ধতি

ইভেন্ট হ্যান্ডলারগুলোকে সঠিকভাবে ব্যবহার করা গুরুত্বপূর্ণ। অন্যথায়, আপনার অ্যাপ্লিকেশন আশাতীত কাজ করবে না।

<span style={{ color: "red" }}>সতর্কতা: ফাংশন পাস করুন, কল করবেন না।</span>
_ইভেন্ট হ্যান্ডলারকে একটি ফাংশন হিসাবে পাস করা উচিত, ফাংশনকে সরাসরি কল উচিত নয়।_

| ঠিক পদ্ধতি: ফাংশন পাস করা                           | ভুল পদ্ধতি: ফাংশন কল করা                                                     | ব্যাখ্যা                                                                                                                         |
| --------------------------------------------------- | ---------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| `<button onClick={handleClick}>ক্লিক করুন</button>` | `<button onClick={handleClick()}>ক্লিক করুন</button>`                        | `handleClick` ফাংশনটি `onClick` ইভেন্ট হ্যান্ডলারকে পাস করা হয়েছে। যখন বোতামটি ক্লিক করা হয়, তখন `handleClick` ফাংশনটি কল হবে। |
| এখানে `handleClick` একটি ফাংশন।                     | এখানে `handleClick()` ফাংশনটি কল করা হচ্ছে এবং এর রিটার্ন মান পাস করা হচ্ছে। | ফাংশনকে ডাকলে ফাংশনের কাজ শেষ হয়ে যায় এবং ইভেন্ট হ্যান্ডলার কাজ করবে না।                                                       |

সঠিক পদ্ধতিঃ

```jsx
<button onClick={() => alert("বোতাম ক্লিক করা হয়েছে")}>ক্লিক করুন</button>
```

এখানে একটি অ্যানোনিমাস ফাংশন তৈরি করা হয়েছে এবং তা onClick ইভেন্ট হ্যান্ডলার হিসাবে পাস করা হয়েছে।

ভুল পদ্ধতিঃ

```jsx
<button onClick={alert("বোতাম ক্লিক করা হয়েছে")}>ক্লিক করুন</button>
```

এখানে alert ফাংশনটি অবিলম্বে কল করা হবে এবং বোতাম ক্লিক হওয়ার আগেই একটি অ্যালার্ট দেখাবে।

সারসংক্ষেপ

- ইভেন্ট হ্যান্ডলারকে একটি ফাংশন হিসাবে পাস করুন।
- ইনলাইন কোড লিখলে অ্যানোনিমাস ফাংশন ব্যবহার করুন।

এখন আপনি জানেন কিভাবে ইভেন্ট হ্যান্ডলারগুলোকে সঠিকভাবে ব্যবহার করতে হয়!

## ইভেন্ট হ্যান্ডলারে প্রপস রিড করা

কারণ ইভেন্ট হ্যান্ডলারগুলো একটি কম্পোনেন্টের অভ্যন্তরে (JSX এ) ঘোষিত হয়, তাই কম্পোনেন্টে আসা প্রপসগুলিতে ইভেন্ট হ্যান্ডেলারের অ্যাক্সেস থাকে।

নিচের কোডটি খেয়াল করুন। এখানে একটি বাটন রয়েছে যা ক্লিক করলে তার মেসেজ প্রপটির সাথে একটি অ্যালার্ট দেখায়:

```jsx
function AlertButton({ message, children }) {
  return <button onClick={() => alert(message)}>{children}</button>;
}

export default function Toolbar() {
  return (
    <div>
      <AlertButton message="Playing!">   সিনেমা প্লে করুন</AlertButton>
      <AlertButton message="Uploading!">ইমেজ আপলোড করুন</AlertButton>  
    </div>
  );
}
```

এটি এই দুটি বাটনে ভিন্ন বার্তা শো করতে দেয়। তাদের কাছে পাস করা বার্তাগুলো চেঞ্জ করে দেখুন।

## ইভেন্ট হ্যান্ডলারগুলো প্রপস হিসাবে পাস করা

প্রায়শই আপনি চাইবেন প্যারেন্ট কম্পোনেন্টকে একটি চাইল্ডের ইভেন্ট হ্যান্ডলার এর মাধ্যমে পরিবর্তন করতে।

প্যারেন্ট থেকে প্রাপ্ত একটি প্রপকে ইভেন্ট হ্যান্ডলার হিসাবে নিম্নলিখিতভাবে পাস করুন:

App.js

```javascript
function Button({ onClick, children }) {
  return <button onClick={onClick}>{children}</button>;
}

function PlayButton({ movieName }) {
  function handlePlayClick() {
    alert(`Playing ${movieName}!`);
  }

  return <Button onClick={handlePlayClick}>Play "{movieName}"</Button>;
}

function UploadButton() {
  return <Button onClick={() => alert("Uploading!")}>Upload Image</Button>;
}

export default function Toolbar() {
  return (
    <div>
      <PlayButton movieName="Kiki's Delivery Service" />
      <UploadButton />
    </div>
  );
}
```

## ইভেন্ট হ্যান্ডেলার প্রপসের নামকরণ

ইভেন্ট হ্যান্ডেলার প্রপসের নামকরণের ক্ষেত্রে খেয়াল রাখা উচিত html এর `onClick, onChange ` reserve keyword ব্যবহার না করাই উচিত।

**`<button>`** এবং **`<div>`** এর মতো বিল্ট-ইন কম্পোনেন্টগুলো শুধুমাত্র `onClick` এর মতো ব্রাউজার ইভেন্ট নামগুলোকেই সাপোর্ট করে। কিন্তু, যখন আপনি নিজের কম্পোনেন্ট তৈরি করবেন, তখন আপনি ইচ্ছামতো তাদের ইভেন্ট হ্যান্ডলার প্রপসগুলোর নামকরণ করতে পারবেন।

সুপারিশ অনুযায়ী, ইভেন্ট হ্যান্ডলার প্রপসগুলো `on` দিয়ে শুরু হওয়া উচিত, তারপর একটি বড় হাতের অক্ষর থাকবে।

উদাহরণস্বরূপ, `Button` কম্পোনেন্টের `onClick` প্রপটিকে `onSmash` নাম দেওয়া যেতে পারত:

```jsx
export default function App() {
  return (
    <Toolbar
      onPlayMovie={() => alert("Playing!")}
      onUploadImage={() => alert("Uploading!")}
    />
  );
}

function Toolbar({ onPlayMovie, onUploadImage }) {
  return (
    <div>
      <Button onClick={onPlayMovie}>Play Movie</Button>
      <Button onClick={onUploadImage}>Upload Image</Button>
    </div>
  );
}

function Button({ onClick, children }) {
  return <button onClick={onClick}>{children}</button>;
}
```

এখানে সমস্যা হলো, যখন আমরা নিজেদের কম্পোনেন্টে onClick props ব্যবহার করে চাইল্ড কম্পোনেন্টে পাঠাবো। তখন চাইল্ড কম্পোনেন্টে `<div>` সহ অন্যান্য ট্যাগ বাটনকে মুড়িয়ে নিতে পারে। তখন বাটন ছাড়াও ui এর অন্যান্য জায়গায় ক্লিক করলেও একটি ঘটনা ঘটবে। যা আমাদের কাম্য নয়।

## ইভেন্টের বি-স্তা-র (Event Propagation)

একটি কম্পোনেন্টের ইভেন্ট হ্যান্ডলাররা তার সাব-কম্পোনেন্ট থেকে আসা ইভেন্টগুলোকেও ধরতে পারে। আমরা বলি যে কোনো ইভেন্ট গাছের মতো উপরে "উঠে আসে" (bubbles) বা "বিস্তার লাভ করে" (propagates): এটি যেখানে ঘটেছিল সেখান থেকে শুরু হয়, এবং তারপর গাছের উপরে উঠে যায়।

এই `<div>` এ দুটি বাটন আছে। উভয় `<div>` এবং প্রতিটি বাটনেরই নিজস্ব `onClick` হ্যান্ডলার আছে। আপনি কি মনে করেন কোন হ্যান্ডলারগুলি চালু হবে যখন আপনি কোনো বাটনে ক্লিক করবেন?

```jsx
// App.js
export default function Toolbar() {
  return (
    <div
      className="Toolbar"
      onClick={() => {
        alert("টুলবারে ক্লিক করলেন!");
      }}
    >
      <button onClick={() => alert("চলচ্চিত্র চালু করুন!")}>
        চলচ্চিত্র চালু করুন
      </button>
      <button onClick={() => alert("ছবি আপলোড করুন!")}>ছবি আপলোড করুন</button>
    </div>
  );
}
```

যদি আপনি যেকোনো বাটনে ক্লিক করেন, তাহলে প্রথমে তার `onClick` চালু হবে, তারপর প্যারেন্ট `<div>` এর `onClick` চালু হবে। সুতরাং, দুটি মেসেজ দেখাবে। যদি আপনি টুলবারে সরাসরি ক্লিক করেন, তাহলে শুধু প্যারেন্ট `<div>` এর `onClick` চালু হবে।

**সাবধানতা**

অন্যান্য সব ইভেন্টই রিয়েক্টে বিস্তার লাভ করে, `onScroll` ছাড়া। এই `onScroll` শুধু সেই JSX ট্যাগেই কাজ করে যেখানে আপনি এটি সংযুক্ত করেন।

## বিস্তার বন্ধ করা (Stopping Propagation)

ইভেন্ট হ্যান্ডলাররা তাদের একমাত্র আর্গুমেন্ট হিসাবে একটি ইভেন্ট অবজেক্ট পায়। সাধারণত, এটিকে `e` বলা হয়, যা "event" (ইভেন্ট) এর জন্য দাঁড়ায়। আপনি এই অবজেক্টটি ব্যবহার করে ইভেন্ট সম্পর্কে তথ্য পড়তে পারেন।

এই ইভেন্ট অবজেক্টটি আপনাকে বিস্তার বন্ধ করতেও দেয়। আপনি যদি কোনো ইভেন্টকে প্যারেন্ট কম্পোনেন্টে পৌঁছানো ঠেকাতে চান, তাহলে আপনাকে `e.stopPropagation()` কল করতে হবে, ঠিক এই বাটন কম্পোনেন্টটির মতো:

```jsx
// App.js
function Button({ onClick, children }) {
  return (
    <button
      onClick={(e) => {
        e.stopPropagation();
        onClick();
      }}
    >
      {children}
    </button>
  );
}

export default function Toolbar() {
  return (
    <div
      className="Toolbar"
      onClick={() => {
        alert("টুলবারে ক্লিক করলেন!");
      }}
    >
      <Button onClick={() => alert("চলচ্চিত্র চালু করুন!")}>
        চলচ্চিত্র চালু করুন
      </Button>
      <Button onClick={() => alert("ছবি আপলোড করুন!")}>ছবি আপলোড করুন</Button>
    </div>
  );
}
```

যখন আপনি কোনো বাটনে ক্লিক করেন:

- রিয়েক্ট `<button>` এ পাঠানো `onClick` হ্যান্ডলারকে কল করে।
- সেই হ্যান্ডলার, `Button` এ সংজ্ঞায়িত, নিম্নলিখিত কাজ করে:
  1. `e.stopPropagation()` কল করে, ইভেন্টকে আরও উপরে উঠতে বাধা দেয়।
  2. `onClick` ফাংশনকে কল করে, যা `Toolbar` কম্পোনেন্ট থেকে পাঠানো একটি প্রপ।
- `Toolbar` কম্পোনেন্টে সংজ্ঞায়িত সেই ফাংশন বাটনের নিজস্ব অ্যালার্ট দেখায়।
- যেহেতু বিস্তার বন্ধ করা হয়েছে, তাই প্যারেন্ট `<div>` এর `onClick` হ্যান্ডলার চালু হয় না।

_`e.stopPropagation()` এর ফলে, বাটনগুলিতে ক্লিক করলে এখন শুধুমাত্র একটি অ্যালার্ট দেখায় (বাটন থেকে), দুটি নয় (বাটন এবং প্যারেন্ট টুলবার `<div>` থেকে)। একটি বাটনে ক্লিক করা তার চারপাশের টুলবারে ক্লিক করার সমান নয়, তাই এই ইউআই এর জন্য বিস্তার বন্ধ করা যুক্তিযুক্ত।_

### ক্যাপচার ফেজ ইভেন্ট (Capture phase events)

এখন পর্যন্ত আমরা শুধুমাত্র "বাবলিং" (bubbling) ফেজ সম্পর্কে কথা বলেছি। এটি হল যেখানে ইভেন্টটি তার টার্গেট থেকে শুরু করে উপরের দিকে বৃদ্ধি পায়। তবে, আরও একটি ফেজ আছে: "ক্যাপচার" (capture) ফেজ।

ক্যাপচার ফেজে, ইভেন্টটি উপর থেকে নিচের দিকে যায়। এটি ডকুমেন্টের শীর্ষ থেকে শুরু হয়, তারপর `html` উপাদান, তারপর অন্যান্য উপাদানগুলোর মধ্য দিয়ে যায়, এবং অবশেষে ইভেন্টের টার্গেটে পৌঁছায়।

আপনি যদি চান, আপনি ক্যাপচার ফেজে ইভেন্ট হ্যান্ডলার যোগ করতে পারেন। এটি করার জন্য, আপনি `onClickCapture` এর পরিবর্তে `onClick` ব্যবহার করবেন।

ক্যাপচার ফেজ সাধারণত ব্যবহার করা হয় না, তবে এটি জানা ভালো যে এটি আছে।

### বিস্তারের বিকল্প হিসাবে হ্যান্ডলার পাস করা (Passing handlers as alternative to propagation)

নোট করুন যে এই ক্লিক হ্যান্ডলার কিছু কোড চালায় এবং তারপর প্যারেন্ট দ্বারা পাঠানো `onClick` প্রপটিকে কল করে:

```jsx
function Button({ onClick, children }) {
  return (
    <button
      onClick={(e) => {
        e.stopPropagation();
        onClick();
      }}
    >
      {children}
    </button>
  );
}
```

আপনি প্যারেন্ট `onClick` ইভেন্ট হ্যান্ডলারকে কল করার আগে এই হ্যান্ডলারে আরও কোড যোগ করতে পারেন। এই প্যাটার্নটি বিস্তারের একটি বিকল্প প্রদান করে। এটি চাইল্ড কম্পোনেন্টকে ইভেন্ট হ্যান্ডেল করতে দেয়, পাশাপাশি প্যারেন্ট কম্পোনেন্টকে কিছু অতিরিক্ত আচরণ নির্দিষ্ট করতে দেয়। বিস্তারের মতো এটি স্বয়ংক্রিয় নয়। তবে এই প্যাটার্নের সুবিধা হল আপনি কোনো ইভেন্টের ফলে কার্যকর হওয়া সম্পূর্ণ কোড চেইন স্পষ্টভাবে অনুসরণ করতে পারেন।

যদি আপনি বিস্তারের উপর নির্ভর করেন এবং কোন হ্যান্ডলারগুলি কার্যকর হয় এবং কেন তা ট্রেস করা কঠিন হয়, তাহলে পরিবর্তে এই পদ্ধতিটি ব্যবহার করার চেষ্টা করুন।

### ডিফল্ট আচরণ প্রতিরোধ করা (Preventing default behavior)

কিছু ব্রাউজার ইভেন্টের সাথে ডিফল্ট আচরণ থাকে। উদাহরণস্বরূপ, একটি `<form>` সাবমিট ইভেন্ট, যা এর ভিতরে একটি বাটনে ক্লিক করার সময় ঘটে, ডিফল্টভাবে পুরো পেজটি রিলোড করবে:

```jsx
// App.js
export default function Signup() {
  return (
    <form onSubmit={() => alert("সাবমিট করা হচ্ছে!")}>
      <input />
      <button>পাঠান</button>
    </form>
  );
}
```

আপনি এটি থেকে বিরত থাকার জন্য ইভেন্ট অবজেক্টে `e.preventDefault()` কল করতে পারেন:

```jsx
// App.js
export default function Signup() {
  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();
        alert("সাবমিট করা হচ্ছে!");
      }}
    >
      <input />
      <button>পাঠান</button>
    </form>
  );
}
```

`e.stopPropagation()` এবং `e.preventDefault()` কে বিভ্রান্ত করবেন না। তারা উভয়ই উপযোগী, কিন্তু একে অপরের সাথে সম্পর্কহীন:

- `e.stopPropagation()` উপরের ট্যাগগুলিতে সংযুক্ত ইভেন্ট হ্যান্ডলারগুলিকে ফায়ার হওয়া থেকে বিরত রাখে।
- `e.preventDefault()` কিছু ইভেন্টের ডিফল্ট ব্রাউজার আচরণকে প্রতিরোধ করে।

## ইভেন্ট হ্যান্ডলারের পার্শ্ব প্রভাব থাকতে পারে?

অবশ্যই! ইভেন্ট হ্যান্ডলাররা পার্শ্ব প্রভাবের জন্য সেরা জায়গা।

রেন্ডারিং ফাংশনের বিপরীতে, ইভেন্ট হ্যান্ডলারদের বিশুদ্ধ হওয়ার দরকার নেই, তাই এটি কিছু পরিবর্তন করার জন্য একটি দুর্দান্ত জায়গা - উদাহরণস্বরূপ, টাইপ করার প্রতিক্রিয়ায় একটি ইনপুটের মান পরিবর্তন করা, বা একটি বাটনে প্রেস করার প্রতিক্রিয়ায় একটি তালিকা পরিবর্তন করা। তবে, কিছু তথ্য পরিবর্তন করার জন্য, আপনাকে প্রথমে এটি সংরক্ষণ করার কোনো উপায় দরকার। রিয়েক্টে, এটি স্টেট ব্যবহার করে করা হয়, একটি কম্পোনেন্টের মেমোরি। আপনি পরবর্তী পৃষ্ঠায় এ সম্পর্কে সবকিছু শিখবেন।

## সংক্ষেপ

- আপনি একটি ফাংশন একটি প্রপ হিসাবে `<button>` এর মতো উপাদানে পাস করে ইভেন্টগুলি হ্যান্ডেল করতে পারেন।
- ইভেন্ট হ্যান্ডলারদের পাস করতে হবে, কল করতে হবে না! `onClick={handleClick}`, `onClick={handleClick()}` নয়।
- আপনি একটি ইভেন্ট হ্যান্ডলার ফাংশন আলাদাভাবে বা ইনলাইনে সংজ্ঞায়িত করতে পারেন।
- ইভেন্ট হ্যান্ডলাররা একটি কম্পোনেন্টের ভিতরে সংজ্ঞায়িত করা হয়, তাই তারা প্রপগুলো অ্যাক্সেস করতে পারে।
- আপনি একটি প্যারেন্টে একটি ইভেন্ট হ্যান্ডলার ঘোষণা করতে পারেন এবং এটিকে একটি প্রপ হিসাবে একটি চাইল্ড কম্পোনেন্টে পাস করতে পারেন।
- আপনি অ্যাপ্লিকেশন-নির্দিষ্ট নামগুলি সহ আপনার নিজের ইভেন্ট হ্যান্ডলার প্রপগুলি সংজ্ঞায়িত করতে পারেন।
- ইভেন্টগুলি উপরে বিস্তার লাভ করে। এটি প্রতিরোধ করতে প্রথম আর্গুমেন্টে `e.stopPropagation()` কল করুন।
- ইভেন্টগুলিতে অবাঞ্ছিত ডিফল্ট ব্রাউজার আচরণ থাকতে পারে। এটি প্রতিরোধ করতে `e.preventDefault()` কল করুন।
- চাইল্ড হ্যান্ডলার থেকে একটি ইভেন্ট হ্যান্ডলার প্রপকে স্পষ্টভাবে কল করা বিস্তারের একটি ভালো বিকল্প।
